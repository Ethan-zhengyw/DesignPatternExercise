# 14 观察者模式

## 定义

### 也叫发布/订阅模式

### 定义了一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够哦自动更新自己

## 使用场景

### 一个对象的改变需要同时改变其他对象的时候

### 并且不知道有多少对象需要改变时

### 实际灵活应用

#### 观察者只需要实现一个观察者接口，实现update方法即可

## 角色

### 主题/通知者

#### 维护一个观察者列表，接受观察者的注册/取消注册请求，在特定事件发生时通知已注册的观察者（即调用观察者的某一方法）

### 观察者/订阅者

## 参数传递

### 也可以在通知时传递事件参数

### 可以在初始化观察者时将通知者赋值给观察者的成员变量

#### 耦合了！

## 解耦实践

### 定义抽象观察者类，具体观察者继承抽象类，可以定义不同的观察者，各自有不同的Action

### 定义抽象通知者

### “依赖倒装原则”的应用，针对接口编程，解除耦合

## 针对通知方法可能发生变化的改进

### 问题

#### 通知者原本是按照统一的、约定好的通知方法去通知观察者，但如果观察者不方便实现抽象观察者类或者就是需要调用已有的特定方法怎么办

### 解决方案：委托

#### 事件委托 vs 观察者模式 改动点

##### 取消抽象观察者类

##### 不同的观察者定义不同的更新方法

##### 抽象通知者不感知抽象观察者，不再维护观察者列表

##### 原本的观察者列表observers被委托类型变量取代

#### 定义

##### 委托就是一种引用方法的类型

##### 一旦为委托分配了方法，委托将与该方法具有完全相同的行为

##### 委托方法的使用可以像其他任何方法一样，具有参数和返回值

##### 委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数

##### 一个委托可以搭载多个方法，所有方法被依次唤起

##### 委托对象所搭载的方法不需要属于同一个类

#### 限制

##### 委托对象所搭载的所有方法必须具有相同的参数列表和返回值类型

###### 为什么？

#### 概念

##### 委托类型

###### delegate void EventHandler();

##### 委托类型变量

###### public event EventHandler update;

####### 可以当成一个列表，注册函数

######## 所注册的函数可以是不同的函数

####### 也可以直接调用，update()，会自动挨个调用已注册的函数

## 观察者模式 vs 代理模式

### 代理模式中的proxy类似观察者模式中的subject，负责调用目标方法

### 代理模式中的proxy实现目标方法，通过成员变量调用真实目标方法

### 代理模式中的proxy调用目标方法的同时可能会又额外的处理，比如检查内容是否已缓存（缓存代理）

### 解决的问题，目的上进行区分

#### 观察者模式

##### 定义了一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够哦自动更新自己

#### 代理模式

##### 为其他对象提供一种代理以控制对这个对象的访问

###### 应用场景

####### 远程代理

######## 为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实

######## 解决远程访问的问题

######### RPC？

####### 虚拟代理

######## 根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真是对象

######## 优化性能

######### 浏览器下载优化，显示过程中图片没下载完就先放张假的提示正在下载

######### 文件/数据库访问缓存

####### 安全代理

######## 用来控制真实对象访问时的权限

####### 智能指引

######## 调用真实的对象时，代理处理另外一些事

######### 访问一个对象时负载一些内务处理

########## 计算真实对象引用次数

########## 检查对象是否已经锁定
