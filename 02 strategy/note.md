# 02 策略模式

## 定义

### 定义了算法家族，分别封装起来，让它们之间可以相互替换，而不会影响到使用算法的客户

## 可以结合简单工程模式使用

## 策略模式 vs 状态模式

### 环境角色的职责不同

#### 两者都有一个叫做Context环境角色的类，但是两者的区别很大

#### 策略模式的环境角色只是一个委托作用，负责算法的替换

#### 而状态模式的环境角色不仅仅是委托行为，它还具有登记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务

### 解决问题的重点不同

#### 策略模式旨在解决内部算法如何改变的问题，也就是将内部算法的改变对外界的影响降低到最小，它保证的是算法可以自由地切换

#### 而状态模式旨在解决内在状态的改变而引起行为改变的问题，它的出发点是事物的状态，封装状态而暴露行为，一个对象的状态改变，从外界来看就好像是行为改变

### 解决问题的方法不同

#### 策略模式只是确保算法可以自由切换，但是什么时候用什么算法它决定不了

#### 而状态模式对外暴露的是行为，状态的变化一般是由环境角色和具体状态共同完成的，也就是说状态模式封装了状态的变化而暴露了不同的行为或行为结果

### 应用场景不同

#### 两者都能实现前面例子中的场景，但并不表示两者的应用场景相同，这只是为了更好地展示出两者的不同而设计的一个场景。

#### 我们来想一下策略模式和状态模式的使用场景有什么不同

##### 策略模式只是一个算法的封装，可以是一个有意义的对象，也可以是一个无意义的逻辑片段，比如MD5加密算法，它是一个有意义的对象吗？不是，它只是我们数学上的一个公式的相关实现，它是一个算法，同时DES算法、RSA算法等都是具体的算法，也就是说它们都是一个抽象算法的具体实现类，从这点来看策略模式是一系列平行的、可相互替换的算法封装后的结果，这就限定了它的应用场景：算法必须是平行的，否则策略模式就封装了一堆垃圾，产生了“坏味道”。

##### 状态模式则要求有一系列状态发生变化的场景，它要求的是有状态且有行为的场景，也就是一个对象必须具有二维（状态和行为）描述才能采用状态模式，如果只有状态而没有行为，则状态的变化就失去了意义。

### 复杂度不同

#### 通常策略模式比较简单，这里的简单指的是结构简单，扩展比较容易，而且代码也容易阅读。当然，一个具体的算法也可以写得很复杂，只有具备很高深的数学、物理等知识的人才可以看懂，这也是允许的，我们只是说从设计模式的角度来分析，它是很容易被看懂的。

#### 而状态模式则通常比较复杂，因为它要从两个角色看到一个对象状态和行为的改变，也就是说它封装的是变化，要知道变化是无穷尽的，因此相对来说状态模式通常都比较复杂，涉及面很多，虽然也很容易扩展，但是一般不会进行大规模的扩张和修正。

### 参考链接

#### https://www.kancloud.cn/sstd521/design/193631

## 策略模式 vs 简单工厂模式

### 相关类的创建方式不同

#### 策略模式

##### 环境类接收的构造参数即某种具体子类，直接用于初始化内部私有策略变量

#### 简单工厂模式

##### 环境类根据构造参数决定具体实例化哪种子类

### 解决的问题侧重点

#### 策略模式

##### 侧重于不改变使用者的调用方式，封装变化（存在一个环境类，环境类提供不变的接口，但接口的行为可根据用户的设定变化）

#### 简单工厂模式

##### 侧重于封装对象的创建逻辑（没有一个“环境类”，只要完成对象的创建即达到目标）
