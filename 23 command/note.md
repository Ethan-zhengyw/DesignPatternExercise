# 23 命令模式

## 使用步骤

### 0. 从用户应用程序客户端main方法开始

### 1. 定义抽象命令类

### 2. 实现具体命令类（命令类的初始化依赖命令执行类）

### 3. 定义命令执行类（Agent）（负责处理/执行命令）

### 4. 定义命令调用（Invoker）类（负责接收客户端的执行命令的请求，通过一个队列/数组进行存储，数组中存放具体命令类对象，通过调用具体命令对象的统一执行方法执行命令）

### 5. 新增命令时

#### 增加具体命令类

#### 新增处理新增命令的命令处理类

## 优点

### 用类表示一个命令，这个命令类知道应该调用谁执行该命令（或这自己也可以处理执行这个命令）

## 使用场景

### 解耦了命令的调用和命令的执行（生产者 - 消费者模型）

#### 发出的命令不用立刻执行，采用其它执行策略时（通过Agent内的容器将命令记录下来，推迟执行）

### 每种类型的命令可以存放在特定的命令队列里，比如Agent命令执行类中包含两个队列：订单创建队列、订单支付队列，提供两个方法create和pay分别消费对应的命令（作业）队列

### 支持undo/redo，如何做到

#### Agent中不只是存储命令列表，还维护当前执行到哪个命令的下标

#### 具体命令类不止提供命令执行接口，还提供命令撤销执行接口（通过执行相反的操作达到undo的作用，要求操作本身是能够支持撤销的）

## 命令模式 vs 备忘录模式

### 都具备撤销/重做功能

### 备忘录模式的主要目的是备份和恢复；命令模式的主要功能是让命令的定义更清晰（通过抽象、继承），解耦命令的调用和命令的执行

### 备忘录模式中的CareTaker类似命令模式中的Agent，负责维护一个容器，不同的是CareTaker维护已备份的对象，Agent维护待执行的命令
