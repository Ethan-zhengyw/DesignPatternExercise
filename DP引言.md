# DP引言

## What

### 总体定义

#### “每一个模式描述了一个在我们周围不断重复发生的问题， 以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”

##### 重复发生的问题

##### 问题解决方案的核心

### 详细描述某一模式

#### 意图

##### 设计模式是做什么的?它的基本原理和意图是什么?它解决的是什么样的特定设计问题?

#### 别名

##### 模式的其他名称。

#### 动机

##### 用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景。该情景 会帮助你理解随后对模式更抽象的描述。

#### 适用性

##### 什么情况下可以使用该设计模式?该模式可用来改进哪些不良设计?你怎样识别这些情 况?

#### 结构

##### 采用基于对象建模技术( O M T ) [ R B P + 9 1 ] 的 表 示 法 对 模 式 中 的 类 进 行 图 形 描 述 。 我 们 也 使用了交互图 [ J C J O 9 2， B O O 9 4 ] 来说明对象之间的请求序列和协作关系。附录 B 详细描述了 这些表示法。

#### 参与者

##### 指设计模式中的类和 /或对象以及它们各自的职责。

#### 协作

##### 模式的参与者怎样协作以实现它们的职责。

#### 效果

##### 模式怎样支持它的目标?使用模式的效果和所需做的权衡取舍?系统结构的哪些方面可以独立改变?

#### 实现

##### 实现模式时需要知道的一些提示、技术要点及应避免的缺陷，以及是否存在某些特定于 实现语言的问题。

#### 代码示例

##### 用来说明怎样用 C + + 或 S m a l l t a l k 实 现 该 模 式 的 代 码 片 段 。

#### 已知应用

##### 实际系统中发现的模式的例子。每个模式至少包括了两个不同领域的实例。

#### 相关模式

##### 与这个模式紧密相关的模式有哪些?其间重要的不同之处是什么?这个模式应与哪些其他模式一起使用?

### 包含内容

#### 分类准则

##### 准则一、目的准则

###### 创建型

####### 与对象的创建有关

###### 结构型

####### 处理类或对象的组合

###### 行为型

####### 对类或对象怎样交互和怎样分配职责进行描述

##### 准则二、范围准则

###### 类

####### 处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了

###### 对象

####### 处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性

#### 类别划分

##### 创建型类模式（将对象的部分创建工作延迟到子类）

###### FactoryMethod(3.3): 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。FactoryMethod使一个类的实例化延迟到其子类。

##### 创建型对象模式（将对象的部分创建工作延迟到另一个对象）

###### AbstractFactory(3.1): 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

###### Builder(3.2): 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

###### Prototype(3.4): 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

###### Singleton(3.5): 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

##### 结构型类模式（使用继承机制来组合类 ）

###### Adapter(4.1)（类）: 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

##### 结构型对象模式（描述了对象的组装方式 ）

###### Adapter(4.1)（对象）: 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

###### Bridge(4.2): 将抽象部分与它的实现部分分离，使它们都可以独立地变化。

###### Composite(4.3): 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。

###### Decorator(4.4): 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。

###### Facade(4.5): 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

###### Flyweight(4.6): 运用共享技术有效地支持大量细粒度的对象。

###### Proxy(4.7): 为其他对象提供一个代理以控制对这个对象的访问。

##### 类行为型（使用继承描述算法和控制流 ）

###### Interpreter(5.3): 给定一个语言,定义它的文法的一种表示，并定义一个解释器,该解释器使用该表示来解释语言中的句子。

###### TemplateMethod(5.10): 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

##### 对象行为型（描述一组对象怎样协作完成单个对象所无法完成的任务）

###### ChainofResponsibility(5.1): 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

###### Command(5.2): 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可取消的操作。

###### Iterator(5.4): 提供一种方法顺序访问一个聚合对象中各个元素,而又不需暴露该对象的内部表示。

###### Mediator(5.5): 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

###### Memento(5.6): 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。

###### Observer(5.7): 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。

###### State(5.8): 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。

###### Strategy(5.9): 定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。

###### Visitor(5.11): 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## Why

### 复用成熟的解决方案，减少重复的劳动

## When

### 常见导致重新设计的场景

#### 1)通过显式地指定一个类来创建对象在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。

##### 设计模式:AbstractFactory(3.1)，FactoryMethod(3.3)，Prototype(3.4)。

#### 2)对特殊操作的依赖当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。

##### 设计模式:ChainofResposibility(5.1)，Command(5.2)。

#### 3)对硬件和软件平台的依赖外部的操作系统接口和应用编程接口(API)在不同的软硬件 平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。

##### 设计模式:AbstractFactory(3.1)，Bridge(4.2)。

#### 4)对对象表示或实现的依赖知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。

##### 设计模式:AbstractFactory(3.1)，Bridge(4.2)，Memento(5.6)，Proxy(4.7)

#### 5)算法依赖算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。

##### 设计模式:Builder(3.2)，Iterator(5.4)，Strategy(5.9)，TemplateMethod(5.10)，Visitor(5.11)

#### 6)紧耦合紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。 松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。

##### 设计模式:AbstractFactory(3.1)，Command(5.2)，Facade(4.5)，Mediator(5.5)，Observer(5.7)，ChainofResponsibility(5.1)。

#### 7)通过生成子类来扩充功能通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等)。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。 一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。

##### 设计模式:Bridge(4.2)，ChainofResponsibility(5.1)，Composite(4.3)，Decorator(4.4)，Observer(5.7)，Strategy(5.9)。

#### 8)不能方便地对类进行修改有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况)，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。

##### 设计模式:Adapter(4.1)，Decorator(4.4)，Visitor(5.11)。

### 限制

#### 设计模式引入额外的间接层次获得灵活性和可变性的同 时，也使设计变得更复杂并 /或牺牲了一定的性能。

#### 一个设计模式只有当它提供的灵活性是 真正需要的时候，才有必要使用。
